# 推荐系统


推荐系统（Recommendation System，简称RS）技术，它根据用户的兴趣、行为、情景等信息，把用户最可能感兴趣的内容主动推送给用户。近年来，推荐系统技术得到了长足的发展，不但成为学术研究的热点之一，而且在电子商务、在线广告、社交网络等重要的互联网应用中大显身手。


## 推荐系统引入

### 基本概念
- **推荐系统定义**：根据用户兴趣、行为、情景等信息，主动推送用户可能感兴趣内容的系统
- **推荐系统与搜索引擎的比较**：
  - 相同点：都是帮助用户发现有用信息的工具
  - 不同点：
    - 搜索引擎：用户需主动提供明确关键词
    - 推荐系统：无需明确需求，通过分析用户历史行为建模兴趣
  - 互补关系：搜索引擎满足有明确目的的查找，推荐系统帮助发现无明确目的时的兴趣

### 发展历史
推荐系统发展分为四个阶段：

1. **探索性阶段**（20世纪90年代中期）
   - 以早期协同过滤系统为代表（如Tapestry系统、GroupLens系统）
   - 标志性事件：1996年3月伯克利举办的协同过滤专题研讨会

2. **商业化阶段**（1995-2000年）
   - MIT的Pattie Maes研究组创立Agents公司（后更名为Firefly Networks）
   - GroupLens研究组创立Net Perceptions
   - 挑战：在不降低网站速度下提供有价值推荐，处理大规模用户和物品

3. **大爆发阶段**（2000-2005年）
   - 推荐系统整合到商业产品线，应用范围扩大
   - 多学科研究引入（人工智能、信息检索、数据挖掘等）
   - 算法研究进步：Netflix大奖（2006年）悬赏100万美元提高预测精度10%

4. **再前进阶段**（2006年至今）
   - 推荐系统研究活跃，专业会议涌现（如Recommenders06、RecSys年会）
   - 研究方向转向基于上下文的推荐和理解用户与机构的互动

### 推荐系统评测指标

#### 用户满意度指标
- **购买率**：用户购买推荐商品的比例
- **点击率**：用户点击推荐内容的比例
- **用户停留时间**：用户在推荐页面的停留时长
- **转化率**：用户完成期望操作的比例
- **问卷调查**：直接询问用户满意度

#### 推荐质量指标
1. **多样性**：
   - 描述推荐列表中物品两两间的不相似性
   - 需覆盖用户不同的兴趣领域

2. **新颖性**：
   - 推荐用户未曾听说过的物品
   - 通过推荐结果的平均流行度粗略衡量（越不热门的物品越新颖）

3. **惊喜度**：
   - 推荐结果与用户历史兴趣不相似但让用户满意
   - 尚无公认的惊喜度指标定义方式

4. **信任度**：
   - 用户对推荐系统的信任程度
   - 通过问卷调查方式度量

5. **实时性**：
   - 推荐具有时效性的物品（如新闻）
   - 确保推荐内容在有效期内

6. **健壮性**（鲁棒性）：
   - 系统抵抗作弊和攻击的能力
   - 如防止刷排名行为

#### 离线评测指标
1. **预测准确度**：
   - **评分预测**：预测用户对未评分物品的评分
     - 均方根误差（RMSE）：
       $$
       RMSE = \sqrt{\frac{\sum_{u,i \in T}(r_{ui} - \hat{r}_{ui})^2}{|T|}}
       $$
     - 平均绝对误差（MAE）：
       $$
       MAE = \frac{\sum_{u,i \in T}|r_{ui} - \hat{r}_{ui}|}{|T|}
       $$
   - **TopN推荐**：预测用户可能喜欢的物品列表
     - 召回率：
       $$
       Recall = \frac{\sum_{u \in U}|R_u \cap T_u|}{\sum_{u \in U}|T(u)|}
       $$
     - 准确率：
       $$
       Precision = \frac{\sum_{u \in U}|R_u \cap T_u|}{\sum_{u \in U}|R(u)|}
       $$

2. **覆盖率**：
   - 描述系统对长尾效应（Long Tail Effect）的发掘能力
   - **覆盖率定义**：推荐系统推荐出的物品占总物品集合的比例
     $$
     Coverage = \frac{|\bigcup_{u \in U} R(u)|}{|I|}
     $$
   - **信息熵**：
     $$
     H = -\sum_{i=1}^{n} p_i \log p(i)
     $$
   - **基尼系数**：
     $$
     G = \frac{1}{n-1} \sum_{j=1}^{n} (2j-n-1)p(i_j)
     $$

## 基于内容的推荐

### 物品表示
基于内容的推荐需为物品建立特征模型：

1. **布尔向量模型**
   - 将所有文档的词语设为列表，用布尔向量表示文档
   - 1表示词语在文档中出现，0表示未出现
   - **问题**：
     - 忽略词语重要性差异
     - 长文档获得更高相关度

2. **TF-IDF向量模型**
   - **词频（TF）**：描述词在文档中的出现频率
     $$
     TF_{i,j} = \frac{freq(i,j)}{maxOthers(i,j)}
     $$
   - **逆向文档频率（IDF）**：降低常见词权重
     $$
     IDF_i = \log \frac{N}{n(i)}
     $$
   - **TF-IDF值**：
     $$
     TF-IDF_{i,j} = TF_{i,j} \times IDF_i
     $$
   - **示例**：在1024篇文档中，词语i在283篇中出现，则IDF=2；文档j中词频20，TF=1，TF-IDF=2

3. **向量空间模型的改进**
   - **停用词处理**：删除介词、冠词等无意义词
   - **词干还原**：将词的不同变形还原为词干（如"stemming"→"stem"）
   - **精简规模**：仅保留信息量最大的n个词语（如128个）
   - **短语处理**：将短语（如"联合国"）作为独立特征
   - **局限性**：
     - 忽略关键词上下文
     - 无法体现"相反语境"（如"素食者"在牛排餐厅描述中）

### 物品相似度
基于内容推荐需计算物品相似度：

1. **基于TF-IDF向量空间文本相似度**
   - 处理流程：
     1. 使用TF-IDF找出两篇文章关键词
     2. 合并关键词集合，计算词频向量
     3. 计算余弦相似度
   - **余弦相似度计算**：
     - 向量A与B的点积：$A \cdot B$
     - 欧几里得范数：$||A||$、$||B||$
     - 相似度：$\cos(A,B) = \frac{A \cdot B}{||A|| \times ||B||}$
   - **示例**：
     - A向量：(1,1,2,1,1,1,0,0,0)
     - B向量：(1,1,1,0,1,1,1,1,1)
     - 相似度：$\cos(A,B) = 0.707$

2. **数值特征的缩放变换**
   - 对非布尔特征（如评分）添加缩放因子
   - **示例**：
     - 电影A和的特征向量：[0,1,1,1,1,0,3]
     - 电影B的特征向量：[1,1,0,1,0,1,4]
     - 添加缩放因子α后余弦相似度变化：
       - α=1: 0.795
       - α=2: 0.959
       - α=0.5: 0.1
   - 缩放因子α的选择影响相似度结果

### 用户对物品的评分
用户-物品评价矩阵表示：
- 设有n个用户$U = \{u_1, ..., u_n\}$
- 设有m个物品$P = \{p_1, ..., p_m\}$
- 评分矩阵$R = \{r_{ij}\}$，$i \in 1...n, j \in 1...m$
- $r_{ij}$表示用户i对物品j的评分（1~5级）

**示例**（用户-物品评价矩阵）：

| 用户   | 电影A | 电影B | 电影C | 电影D |
|--------|-------|-------|-------|-------|
| User1  | 4     | ?     | 2     | 3     |
| User2  | 2     | 5     | 3     |       |
| User3  |       | 3     | 5     |       |
| User4  | 3     | 4     |       |       |

### 基于向量空间模型的推荐
基于向量空间模型的推荐方法：

1. **最近邻方法**
   - 基本思想：查找与用户过去喜欢的物品相似的物品
   - 步骤：
     1. 计算候选物品与用户偏好物品的相似度
     2. 取k个最相似的物品进行"投票"
     3. 根据投票结果推荐
   - 参数：
     - k值（近邻数量）
     - 评分的二元化处理
     - 相似度阈值设置
     - 投票权重分配

2. **相关性反馈-Rocchio方法**
   - 源自信息检索系统SMART
   - 主要思想：根据用户反馈优化查询向量
   - 处理流程：
     1. 将评分文档分为两组：$D^+$（喜欢）和$D^-$（不喜欢）
     2. 计算两组的平均向量（重心点）
     3. 优化查询向量：
        $$
        Q_{i+1} = \alpha \cdot Q_i + \beta \cdot \frac{1}{|D^+|} \sum_{d^+ \in D^+} d^+ - \gamma \cdot \frac{1}{|D^-|} \sum_{d^- \in D^-} d^-
        $$
     - 参数：$\alpha$（初始查询权重）、$\beta$（正反馈强度）、$\gamma$（负反馈强度）
   - 效果：查询向量向相关文档聚类移动

**示例**：
- 初始查询$Q_0$经反馈后移动到$Q_1$，靠近相关文档聚类
- 合适参数值：$\alpha=8, \beta=16, \gamma=4$（或1,2,0.5）



## 协同过滤

### 协同过滤基本概念
协同过滤是目前研究最多、应用最成熟的个性化推荐技术，分为：
1. **基于用户**：找到与目标用户相似的用户集合（近邻），基于这些用户对物品的评分进行预测
2. **基于物品**：找到与目标物品相似的物品集合，基于用户对这些相似物品的评分进行预测
3. **基于模型**：通过训练模型（如矩阵分解）预测评分

**用户-物品评价模型**：
- 使用n×m阶用户-物品评价矩阵R表示用户对物品的评分
- 评分获取方式：
  - **显式评分**：用户明确表达喜好，如评分、喜欢/不喜欢
  - **隐式评分**：通过用户行为推断喜好，如点击、浏览时间、购买记录等

**评分标准化**：
- **均值中心化**：将用户评分转换为与该用户平均评分的偏差
  - 公式：$h_{ui} = r_{ui} - r_u$，其中$r_u$是用户u对所有物品评分的平均值

**稀疏矩阵问题**：
- 实际应用中，用户通常只对少数物品评分，导致评分矩阵非常稀疏
- 解决方法包括：扩展激活方法、使用降维技术等

### 基于用户的协同过滤
基于用户的协同过滤算法分为三个阶段：
1. **表示阶段**：构建用户-物品评分矩阵
2. **近邻选择阶段**：计算目标用户与其他用户的相似度，选择k个最相似的近邻
3. **推荐产生阶段**：基于近邻的评分预测目标用户对未知物品的评分

**相似度度量**：
- 使用Pearson相关系数计算用户相似度，考虑了评分标准化的影响
  - 公式：
    $$
    \text{sim}(a,b) = \frac{\sum_{p \in P} (r_{a,p} - r_a)(r_{b,p} - r_b)}{\sqrt{\sum_{p \in P} (r_{a,p} - r_a)^2} \sqrt{\sum_{p \in P} (r_{b,p} - r_b)^2}}
    $$

**推荐产生**：
- 预测用户u对物品p的评分：
  - 公式：
    $$
    \text{pred}_{a,p} = r_a + \frac{\sum_{b \in S(a,K) \cap N(p)} \text{sim}(a,b) \cdot (r_{b,p} - r_b)}{\sum_{b \in K} \text{sim}(a,b)}
    $$
  - 其中：
    - S(a,K)：与用户a最相似的K个用户集合
    - N(p)：对物品p评分的用户集合
    - r_a：用户a的平均评分



### 基于物品的协同过滤
基于物品的协同过滤假设：用户对相似物品的评分相近。

**相似度度量**：
- **基本余弦相似度**：
  - 将物品表示为评分向量，计算余弦相似度
  - 公式：
    $$
    \text{sim}(a,b) = \frac{\vec{a} \cdot \vec{b}}{||\vec{a}|| \cdot ||\vec{b}||}
    $$
- **改进的余弦相似度**：考虑用户评分平均值差异
  - 公式：
    $$
    \text{sim}(a,b) = \frac{\sum_{u \in U} (r_{u,a} - r_u)(r_{u,b} - r_u)}{\sqrt{\sum_{u \in U} (r_{u,a} - r_u)^2} \sqrt{\sum_{u \in U} (r_{u,b} - r_u)^2}}
    $$

**推荐产生**：
- 预测用户u对物品p的评分：
  - 公式：
    $$
    \text{pred}_{u,p} = r_p + \frac{\sum_{j \in S(p,K) \cap N(u)} \text{sim}(j,p) \cdot (r_{u,j} - r_j)}{\sum_{j \in S(p,K) \cap N(u)} \text{sim}(j,p)}
    $$

### 隐语义模型和矩阵因子分解模型（不考）
**隐语义模型（Latent Factor Model, LFM）**：
- 将用户-物品评分矩阵分解为用户特征矩阵和物品特征矩阵的乘积
  - 公式：$\hat{R} = P^T Q$
    - P：f×n矩阵，每列表示用户特征向量
    - Q：f×m矩阵，每列表示物品特征向量
    - f：隐因子维度（超参数）
- 预测公式：$\hat{r}_{ui} = \sum_{f=1}^{F} p_{uf} \cdot q_{if}$

**加入偏置项的LFM**：
- 考虑全局平均、用户偏置和物品偏置：
  - 公式：$\hat{r}_{ui} = \mu + b_u + b_i + p_u^T q_i$
- 损失函数（带正则化）：
  $$
  C_{p,q} = \sum_{(u,i) \in T} (r_{ui} - \mu - b_u - b_i - p_u^T q_i)^2 + \lambda (b_u^2 + b_i^2 + p_u^2 + q_i^2)
  $$

**SVD++模型**：
- 在LFM基础上，引入用户的历史评分物品集合：
  - 公式：
    $$
    \hat{r}_{ui} = \mu + b_i + b_u + q_i^T \left( p_u + |R_u|^{-1/2} \sum_{j \in R_u} y_j \right)
    $$

**时间敏感的因子模型**：
- 将用户偏置、物品偏置和用户偏好表示为时间函数：
  - 用户偏置：$b_u(t)$
  - 物品偏置：$b_i(t)$
  - 用户偏好：$p_u(t)$

## 8.4 其他推荐技术
除了基于内容和协同过滤，还有以下推荐技术：

1. **关联规则推荐**：
   - 基于关联规则挖掘用户-物品关系
   - 例如：{A, B} → C 表示购买了A和B的用户也可能会购买C

2. **基于知识的推荐**：
   - 利用领域知识和用户偏好模型进行推荐
   - 例如：基于案例推理（CBR）或知识图谱

3. **基于效用的推荐**：
   - 推荐效用最大化的物品，考虑用户效用函数
   - 例如：根据用户属性和物品属性计算效用得分

4. **基于人口统计信息的推荐**：
   - 根据用户的人口统计特征（年龄、性别等）分组，推荐组内热门物品
   - 缺点：忽视个性化

5. **基于网络结构的推荐**：
   - 将用户-物品交互建模为二部图，利用图算法推荐
   - 例如：随机游走、标签传播

6. **混合推荐**：
   - 组合多种推荐方法，提高推荐效果
   - 例如：加权混合、切换混合、级联混合

## 8.5 实战：基于协同过滤算法推荐电影
使用Spark MLlib的ALS算法实现电影推荐。

### 环境配置
- Hadoop 2.5集群
- Hadoop 2.7.3
- Spark 1.6.2
- Scala 2.1.0

### 数据准备
- **数据集**：MovieLens ml-20m（包含138,000用户对27,000部电影的2,000万条评分）
- **数据文件**：
  - movies.dat：电影信息（电影ID、标题、类型）
  - ratings.dat：用户评分（用户ID、电影ID、评分、时间戳）

### 实施步骤
1. **数据准备与导入**：
   ```scala
   case class Movie(id: Int, title: String, genres: String)
   val movies = sc.textFile("movies.dat").map(_.split(",")).map(row => Movie(row(0).toInt, row(1), row(2)))
   val ratings = sc.textFile("ratings.dat").map(_.split(",")).map(row => Rating(row(0).toInt, row(1).toInt, row(2).toDouble))
   ```

2. **数据集划分**：
   ```scala
   val Array(trainingSet, testSet) = ratings.randomSplit(Array(0.8, 0.2))
   ```

3. **训练模型**：
   ```scala
   val als = new ALS()
     .setMaxIter(10)
     .setRegParam(0.01)
     .setRank(10) // 隐因子维度
     .setUserCol("user")
     .setItemCol("product")
     .setRatingCol("rating")
   val model = als.fit(trainingSet)
   ```

4. **推荐预测与验证**：
   - 生成推荐列表：
     ```scala
     val userRecs = model.recommendProductsForUsers(10) // 每个用户推荐10个物品
     val user168Recs = model.recommendProducts(168, 10) // 用户168的推荐
     ```
   - 模型验证（MAE）：
     ```scala
     val predictions = model.transform(testSet)
     val evaluator = new RegressionEvaluator()
       .setMetricName("mae")
       .setLabelCol("rating")
       .setPredictionCol("prediction")
     val mae = evaluator.evaluate(predictions) // MAE=0.7403
     ```

### 实验结果
- **推荐结果示例**（用户168）：
  1. 电影标题1
  2. 电影标题2
  3. ...
  10. 电影标题10
- **模型验证**：MAE=0.7403（小于1，模型合理）

## 习题
1. **推荐系统定义**：根据用户兴趣、行为、情景等信息主动推送可能感兴趣内容的系统。
   **发展历史**：分为探索性阶段（20世纪90年代中期）、商业化阶段（1995-2000）、大爆发阶段（2000-2005）、再前进阶段（2006至今）。

2. **计算机相似度计算**：
   - 特征向量：
     - A: [3.06, 500, 4] → [3.06, α×500, β×4]
     - B: [2.68, 320, 6] → [2.68, α×320, β×6]
     - C: [2.92, 640, 4] → [2.92, α×640, β×4]
   - (1) 基于α和β计算余弦相似度
   - (2) 当α=β=1时，计算各对余弦值
   - (3) 当α=0.01, β=0.5时，重新计算

3. **电影评分预测**（用户-物品矩阵）：
   - **基于用户**：
     - (1) 计算用户3与其他用户的Pearson相似度
     - (2) 选择相似度大于0.5的近邻，预测用户3对电影B的评分
   - **基于物品**：
     - (3) 计算电影B与其他电影的改进余弦相似度
     - (4) 选择相似度大于0.5的物品，预测用户3对电影B的评分
```